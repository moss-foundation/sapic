// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
pub type Value = plugin::base::types::Value;
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_execute_cabi<T: Guest>(arg0: i32, arg1: *mut u8, arg2: i64) -> *mut u8 {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    use plugin::base::types::Value as V29;
    let v29 = match arg0 {
        0 => V29::Null,
        1 => {
            let e29 = _rt::bool_lift(arg1 as i32 as u8);
            V29::Boolean(e29)
        }
        2 => {
            let e29 = {
                use plugin::base::types::Number as V0;
                let v0 = match arg1 as i32 {
                    0 => {
                        let e0 = arg2;
                        V0::Signed(e0)
                    }
                    1 => {
                        let e0 = arg2 as u64;
                        V0::Unsigned(e0)
                    }
                    n => {
                        debug_assert_eq!(n, 2, "invalid enum discriminant");
                        let e0 = f64::from_bits(arg2 as u64);
                        V0::Float(e0)
                    }
                };
                v0
            };
            V29::Num(e29)
        }
        3 => {
            let e29 = {
                let len1 = arg2 as usize;
                let bytes1 = _rt::Vec::from_raw_parts(arg1.cast(), len1, len1);
                _rt::string_lift(bytes1)
            };
            V29::Str(e29)
        }
        4 => {
            let e29 = {
                let base13 = arg1;
                let len13 = arg2 as usize;
                let mut result13 = _rt::Vec::with_capacity(len13);
                for i in 0..len13 {
                    let base = base13.add(i * 24);
                    let e13 = {
                        let l2 = i32::from(*base.add(0).cast::<u8>());
                        use plugin::base::types::SimpleValue as V12;
                        let v12 = match l2 {
                            0 => V12::Null,
                            1 => {
                                let e12 = {
                                    let l3 = i32::from(*base.add(8).cast::<u8>());
                                    _rt::bool_lift(l3 as u8)
                                };
                                V12::Boolean(e12)
                            }
                            2 => {
                                let e12 = {
                                    let l4 = i32::from(*base.add(8).cast::<u8>());
                                    use plugin::base::types::Number as V8;
                                    let v8 = match l4 {
                                        0 => {
                                            let e8 = {
                                                let l5 = *base.add(16).cast::<i64>();
                                                l5
                                            };
                                            V8::Signed(e8)
                                        }
                                        1 => {
                                            let e8 = {
                                                let l6 = *base.add(16).cast::<i64>();
                                                l6 as u64
                                            };
                                            V8::Unsigned(e8)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e8 = {
                                                let l7 = *base.add(16).cast::<f64>();
                                                l7
                                            };
                                            V8::Float(e8)
                                        }
                                    };
                                    v8
                                };
                                V12::Num(e12)
                            }
                            n => {
                                debug_assert_eq!(n, 3, "invalid enum discriminant");
                                let e12 = {
                                    let l9 = *base.add(8).cast::<*mut u8>();
                                    let l10 = *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len11 = l10;
                                    let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                                    _rt::string_lift(bytes11)
                                };
                                V12::Str(e12)
                            }
                        };
                        v12
                    };
                    result13.push(e13);
                }
                _rt::cabi_dealloc(base13, len13 * 24, 8);
                result13
            };
            V29::Arr(e29)
        }
        n => {
            debug_assert_eq!(n, 5, "invalid enum discriminant");
            let e29 = {
                let base28 = arg1;
                let len28 = arg2 as usize;
                let mut result28 = _rt::Vec::with_capacity(len28);
                for i in 0..len28 {
                    let base = base28.add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
                    let e28 = {
                        let l14 = *base.add(0).cast::<*mut u8>();
                        let l15 = *base
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len16 = l15;
                        let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);
                        let l17 = i32::from(
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        use plugin::base::types::SimpleValue as V27;
                        let v27 = match l17 {
                            0 => V27::Null,
                            1 => {
                                let e27 = {
                                    let l18 = i32::from(
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    _rt::bool_lift(l18 as u8)
                                };
                                V27::Boolean(e27)
                            }
                            2 => {
                                let e27 = {
                                    let l19 = i32::from(
                                        *base
                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    use plugin::base::types::Number as V23;
                                    let v23 = match l19 {
                                        0 => {
                                            let e23 = {
                                                let l20 = *base
                                                    .add(
                                                        16 + 2 * ::core::mem::size_of::<*const u8>(
                                                        ),
                                                    )
                                                    .cast::<i64>();
                                                l20
                                            };
                                            V23::Signed(e23)
                                        }
                                        1 => {
                                            let e23 = {
                                                let l21 = *base
                                                    .add(
                                                        16 + 2 * ::core::mem::size_of::<*const u8>(
                                                        ),
                                                    )
                                                    .cast::<i64>();
                                                l21 as u64
                                            };
                                            V23::Unsigned(e23)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e23 = {
                                                let l22 = *base
                                                    .add(
                                                        16 + 2 * ::core::mem::size_of::<*const u8>(
                                                        ),
                                                    )
                                                    .cast::<f64>();
                                                l22
                                            };
                                            V23::Float(e23)
                                        }
                                    };
                                    v23
                                };
                                V27::Num(e27)
                            }
                            n => {
                                debug_assert_eq!(n, 3, "invalid enum discriminant");
                                let e27 = {
                                    let l24 = *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l25 = *base
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len26 = l25;
                                    let bytes26 =
                                        _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                                    _rt::string_lift(bytes26)
                                };
                                V27::Str(e27)
                            }
                        };
                        (_rt::string_lift(bytes16), v27)
                    };
                    result28.push(e28);
                }
                _rt::cabi_dealloc(
                    base28,
                    len28 * (24 + 2 * ::core::mem::size_of::<*const u8>()),
                    8,
                );
                result28
            };
            V29::Obj(e29)
        }
    };
    let result30 = T::execute(v29);
    let ptr31 = (&raw mut _RET_AREA.0).cast::<u8>();
    use plugin::base::types::Value as V44;
    match result30 {
        V44::Null => {
            *ptr31.add(0).cast::<u8>() = (0i32) as u8;
        }
        V44::Boolean(e) => {
            *ptr31.add(0).cast::<u8>() = (1i32) as u8;
            *ptr31.add(8).cast::<u8>() = (match e {
                true => 1,
                false => 0,
            }) as u8;
        }
        V44::Num(e) => {
            *ptr31.add(0).cast::<u8>() = (2i32) as u8;
            use plugin::base::types::Number as V32;
            match e {
                V32::Signed(e) => {
                    *ptr31.add(8).cast::<u8>() = (0i32) as u8;
                    *ptr31.add(16).cast::<i64>() = _rt::as_i64(e);
                }
                V32::Unsigned(e) => {
                    *ptr31.add(8).cast::<u8>() = (1i32) as u8;
                    *ptr31.add(16).cast::<i64>() = _rt::as_i64(e);
                }
                V32::Float(e) => {
                    *ptr31.add(8).cast::<u8>() = (2i32) as u8;
                    *ptr31.add(16).cast::<f64>() = _rt::as_f64(e);
                }
            }
        }
        V44::Str(e) => {
            *ptr31.add(0).cast::<u8>() = (3i32) as u8;
            let vec33 = (e.into_bytes()).into_boxed_slice();
            let ptr33 = vec33.as_ptr().cast::<u8>();
            let len33 = vec33.len();
            ::core::mem::forget(vec33);
            *ptr31
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>() = len33;
            *ptr31.add(8).cast::<*mut u8>() = ptr33.cast_mut();
        }
        V44::Arr(e) => {
            *ptr31.add(0).cast::<u8>() = (4i32) as u8;
            let vec37 = e;
            let len37 = vec37.len();
            let layout37 = _rt::alloc::Layout::from_size_align_unchecked(vec37.len() * 24, 8);
            let result37 = if layout37.size() != 0 {
                let ptr = _rt::alloc::alloc(layout37).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout37);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec37.into_iter().enumerate() {
                let base = result37.add(i * 24);
                {
                    use plugin::base::types::SimpleValue as V36;
                    match e {
                        V36::Null => {
                            *base.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        V36::Boolean(e) => {
                            *base.add(0).cast::<u8>() = (1i32) as u8;
                            *base.add(8).cast::<u8>() = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        V36::Num(e) => {
                            *base.add(0).cast::<u8>() = (2i32) as u8;
                            use plugin::base::types::Number as V34;
                            match e {
                                V34::Signed(e) => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V34::Unsigned(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                }
                                V34::Float(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                }
                            }
                        }
                        V36::Str(e) => {
                            *base.add(0).cast::<u8>() = (3i32) as u8;
                            let vec35 = (e.into_bytes()).into_boxed_slice();
                            let ptr35 = vec35.as_ptr().cast::<u8>();
                            let len35 = vec35.len();
                            ::core::mem::forget(vec35);
                            *base
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len35;
                            *base.add(8).cast::<*mut u8>() = ptr35.cast_mut();
                        }
                    }
                }
            }
            *ptr31
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>() = len37;
            *ptr31.add(8).cast::<*mut u8>() = result37;
        }
        V44::Obj(e) => {
            *ptr31.add(0).cast::<u8>() = (5i32) as u8;
            let vec43 = e;
            let len43 = vec43.len();
            let layout43 = _rt::alloc::Layout::from_size_align_unchecked(
                vec43.len() * (24 + 2 * ::core::mem::size_of::<*const u8>()),
                8,
            );
            let result43 = if layout43.size() != 0 {
                let ptr = _rt::alloc::alloc(layout43).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout43);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec43.into_iter().enumerate() {
                let base = result43.add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
                {
                    let (t38_0, t38_1) = e;
                    let vec39 = (t38_0.into_bytes()).into_boxed_slice();
                    let ptr39 = vec39.as_ptr().cast::<u8>();
                    let len39 = vec39.len();
                    ::core::mem::forget(vec39);
                    *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len39;
                    *base.add(0).cast::<*mut u8>() = ptr39.cast_mut();
                    use plugin::base::types::SimpleValue as V42;
                    match t38_1 {
                        V42::Null => {
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                        V42::Boolean(e) => {
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        V42::Num(e) => {
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (2i32) as u8;
                            use plugin::base::types::Number as V40;
                            match e {
                                V40::Signed(e) => {
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                    *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                V40::Unsigned(e) => {
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                V40::Float(e) => {
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                    *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(e);
                                }
                            }
                        }
                        V42::Str(e) => {
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (3i32) as u8;
                            let vec41 = (e.into_bytes()).into_boxed_slice();
                            let ptr41 = vec41.as_ptr().cast::<u8>();
                            let len41 = vec41.len();
                            ::core::mem::forget(vec41);
                            *base
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len41;
                            *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr41.cast_mut();
                        }
                    }
                }
            }
            *ptr31
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>() = len43;
            *ptr31.add(8).cast::<*mut u8>() = result43;
        }
    }
    ptr31
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_execute<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        1 => {}
        2 => {}
        3 => {
            let l1 = *arg0.add(8).cast::<*mut u8>();
            let l2 = *arg0
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
        4 => {
            let l3 = *arg0.add(8).cast::<*mut u8>();
            let l4 = *arg0
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base8 = l3;
            let len8 = l4;
            for i in 0..len8 {
                let base = base8.add(i * 24);
                {
                    let l5 = i32::from(*base.add(0).cast::<u8>());
                    match l5 {
                        0 => {}
                        1 => {}
                        2 => {}
                        _ => {
                            let l6 = *base.add(8).cast::<*mut u8>();
                            let l7 = *base
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l6, l7, 1);
                        }
                    }
                }
            }
            _rt::cabi_dealloc(base8, len8 * 24, 8);
        }
        _ => {
            let l9 = *arg0.add(8).cast::<*mut u8>();
            let l10 = *arg0
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base16 = l9;
            let len16 = l10;
            for i in 0..len16 {
                let base = base16.add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l11 = *base.add(0).cast::<*mut u8>();
                    let l12 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l11, l12, 1);
                    let l13 = i32::from(
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    match l13 {
                        0 => {}
                        1 => {}
                        2 => {}
                        _ => {
                            let l14 = *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *base
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l14, l15, 1);
                        }
                    }
                }
            }
            _rt::cabi_dealloc(
                base16,
                len16 * (24 + 2 * ::core::mem::size_of::<*const u8>()),
                8,
            );
        }
    }
}
pub trait Guest {
    fn execute(input: Value) -> Value;
}
#[doc(hidden)]
macro_rules! __export_world_echo_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "execute")] unsafe extern "C" fn
        export_execute(arg0 : i32, arg1 : * mut u8, arg2 : i64,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_execute_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
        (export_name = "cabi_post_execute")] unsafe extern "C" fn
        _post_return_execute(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_execute::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_echo_cabi;
#[repr(align(8))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod plugin {
    pub mod base {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone, Copy)]
            pub enum Number {
                Signed(i64),
                Unsigned(u64),
                Float(f64),
            }
            impl ::core::fmt::Debug for Number {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Number::Signed(e) => {
                            f.debug_tuple("Number::Signed").field(e).finish()
                        }
                        Number::Unsigned(e) => {
                            f.debug_tuple("Number::Unsigned").field(e).finish()
                        }
                        Number::Float(e) => {
                            f.debug_tuple("Number::Float").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum SimpleValue {
                Null,
                Boolean(bool),
                Num(Number),
                Str(_rt::String),
            }
            impl ::core::fmt::Debug for SimpleValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SimpleValue::Null => f.debug_tuple("SimpleValue::Null").finish(),
                        SimpleValue::Boolean(e) => {
                            f.debug_tuple("SimpleValue::Boolean").field(e).finish()
                        }
                        SimpleValue::Num(e) => {
                            f.debug_tuple("SimpleValue::Num").field(e).finish()
                        }
                        SimpleValue::Str(e) => {
                            f.debug_tuple("SimpleValue::Str").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum Value {
                Null,
                Boolean(bool),
                Num(Number),
                Str(_rt::String),
                Arr(_rt::Vec<SimpleValue>),
                Obj(_rt::Vec<(_rt::String, SimpleValue)>),
            }
            impl ::core::fmt::Debug for Value {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Value::Null => f.debug_tuple("Value::Null").finish(),
                        Value::Boolean(e) => {
                            f.debug_tuple("Value::Boolean").field(e).finish()
                        }
                        Value::Num(e) => f.debug_tuple("Value::Num").field(e).finish(),
                        Value::Str(e) => f.debug_tuple("Value::Str").field(e).finish(),
                        Value::Arr(e) => f.debug_tuple("Value::Arr").field(e).finish(),
                        Value::Obj(e) => f.debug_tuple("Value::Obj").field(e).finish(),
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod host_functions {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Value = super::super::super::plugin::base::types::Value;
            #[allow(unused_unsafe, clippy::all)]
            pub fn greet(content: &Value) -> () {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    use super::super::super::plugin::base::types::Value as V13;
                    let (result14_0, result14_1, result14_2) = match content {
                        V13::Null => (0i32, ::core::ptr::null_mut(), 0i64),
                        V13::Boolean(e) => {
                            (
                                1i32,
                                match e {
                                    true => 1,
                                    false => 0,
                                } as *mut u8,
                                0i64,
                            )
                        }
                        V13::Num(e) => {
                            use super::super::super::plugin::base::types::Number as V0;
                            let (result1_0, result1_1) = match e {
                                V0::Signed(e) => (0i32, _rt::as_i64(e)),
                                V0::Unsigned(e) => (1i32, _rt::as_i64(e)),
                                V0::Float(e) => (2i32, (_rt::as_f64(e)).to_bits() as i64),
                            };
                            (2i32, result1_0 as *mut u8, result1_1)
                        }
                        V13::Str(e) => {
                            let vec2 = e;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            (3i32, ptr2.cast_mut(), len2 as i64)
                        }
                        V13::Arr(e) => {
                            let vec6 = e;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * 24,
                                8,
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 24);
                                {
                                    use super::super::super::plugin::base::types::SimpleValue as V5;
                                    match e {
                                        V5::Null => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        V5::Boolean(e) => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                            *base.add(8).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        V5::Num(e) => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                            use super::super::super::plugin::base::types::Number as V3;
                                            match e {
                                                V3::Signed(e) => {
                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V3::Unsigned(e) => {
                                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                                    *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V3::Float(e) => {
                                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                                    *base.add(16).cast::<f64>() = _rt::as_f64(e);
                                                }
                                            }
                                        }
                                        V5::Str(e) => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                            let vec4 = e;
                                            let ptr4 = vec4.as_ptr().cast::<u8>();
                                            let len4 = vec4.len();
                                            *base
                                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len4;
                                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result6, layout6)]);
                            (4i32, result6, len6 as i64)
                        }
                        V13::Obj(e) => {
                            let vec12 = e;
                            let len12 = vec12.len();
                            let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec12.len()
                                    * (24 + 2 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result12 = if layout12.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout12);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec12.into_iter().enumerate() {
                                let base = result12
                                    .add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t7_0, t7_1) = e;
                                    let vec8 = t7_0;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *base.add(0).cast::<*mut u8>() = ptr8.cast_mut();
                                    use super::super::super::plugin::base::types::SimpleValue as V11;
                                    match t7_1 {
                                        V11::Null => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                        V11::Boolean(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                        V11::Num(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                            use super::super::super::plugin::base::types::Number as V9;
                                            match e {
                                                V9::Signed(e) => {
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                    *base
                                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V9::Unsigned(e) => {
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *base
                                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i64>() = _rt::as_i64(e);
                                                }
                                                V9::Float(e) => {
                                                    *base
                                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (2i32) as u8;
                                                    *base
                                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<f64>() = _rt::as_f64(e);
                                                }
                                            }
                                        }
                                        V11::Str(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            let vec10 = e;
                                            let ptr10 = vec10.as_ptr().cast::<u8>();
                                            let len10 = vec10.len();
                                            *base
                                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len10;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr10.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result12, layout12)]);
                            (5i32, result12, len12 as i64)
                        }
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "plugin:base/host-functions")]
                    unsafe extern "C" {
                        #[link_name = "greet"]
                        fn wit_import15(_: i32, _: *mut u8, _: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import15(_: i32, _: *mut u8, _: i64) {
                        unreachable!()
                    }
                    unsafe { wit_import15(result14_0, result14_1, result14_2) };
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub use alloc_crate::alloc;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_echo_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_echo_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_echo_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.41.0:plugin:echo:echo:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 464] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd5\x02\x01A\x02\x01\
A\x08\x01B\x09\x01q\x03\x06signed\x01x\0\x08unsigned\x01w\0\x05float\x01u\0\x04\0\
\x06number\x03\0\0\x01q\x04\x04null\0\0\x07boolean\x01\x7f\0\x03num\x01\x01\0\x03\
str\x01s\0\x04\0\x0csimple-value\x03\0\x02\x01p\x03\x01o\x02s\x03\x01p\x05\x01q\x06\
\x04null\0\0\x07boolean\x01\x7f\0\x03num\x01\x01\0\x03str\x01s\0\x03arr\x01\x04\0\
\x03obj\x01\x06\0\x04\0\x05value\x03\0\x07\x03\0\x11plugin:base/types\x05\0\x02\x03\
\0\0\x05value\x03\0\x05value\x03\0\x01\x01B\x04\x02\x03\x02\x01\x01\x04\0\x05val\
ue\x03\0\0\x01@\x01\x07content\x01\x01\0\x04\0\x05greet\x01\x02\x03\0\x1aplugin:\
base/host-functions\x05\x03\x01@\x01\x05input\x02\0\x02\x04\0\x07execute\x01\x04\
\x04\0\x10plugin:echo/echo\x04\0\x0b\x0a\x01\0\x04echo\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
