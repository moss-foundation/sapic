// host.com
// host.com#fragment
// host.com?query
// host.com?query=
// host.com?query=1
// host.com?query=1#fragment
// host.com/
// host.com/#fragment
// host.com/path
// host.com/path#fragment
// host.com/path?query=1
// host.com/path?query=1#fragment

// A simplified version of RFC-3986
unreserved = {ASCII_ALPHANUMERIC | "-" | "." | "_" | "~" }
sub_delims = { "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" }

// Technically, the specification allows colon to be used in path part
// However we reserved it for path variables
// The user can still bypass this constraint by storing the colon literal in the path variable
p_char = {unreserved | sub_delims | "%" | "@"}


ident = @{ (ASCII_ALPHANUMERIC | "_" )+ }
var = { "{{" ~ ident ~ "}}" }
path_var = { ":" ~ ident }

url = {
    SOI ~
    scheme_part? ~
    host_part ~
    path_part? ~
    query_part? ~
    fragment_part? ~
    EOI
}

scheme_part = { (var | scheme_literal)+ ~ "://" }
scheme_literal = @{
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "+" | "-" | ".")*
}

// HOST
host_part  = { (var | host_raw)+ ~ "/"? }
host_raw   = @{ (unreserved | sub_delims | "%")+ }

// PATH
path_part  = {  (path_var | path_raw)+ }
path_raw   = @{ (p_char | "/")+ }

// QUERY
query_part = {
    "?" ~ query_param ~ ("&" ~ query_param)*
}
query_param = { query_key ~ ("=" ~ query_value)?}
query_key = { (var | query_raw)+}
// Allow for empty string as value
query_value = { (var | query_raw)*}
query_raw = @{ (!("&" | "=") ~ p_char | ":" | "/" | "?")+ }


fragment_part = { "#" ~ (var | fragment_raw)* }
fragment_raw = @{ (p_char | ":" | "/" | "?")+ }

// Variable rule -> parser used by either url or body parser
// Find out if it supports import?